--========================
-- OVERHUB UI (SMALLER) + EXPORTS
--========================

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- Blur
local camera = workspace.CurrentCamera
local Blur = Instance.new("BlurEffect")
Blur.Enabled = true
Blur.Size = 0
Blur.Parent = camera

-- cleanup old
for _, n in ipairs({"DiamondFarmGUI","AutoFarmDiamondsGUI"}) do
    local f = PlayerGui:FindFirstChild(n)
    if f then f:Destroy() end
end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoFarmDiamondsGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = PlayerGui

local Root = Instance.new("Frame")
Root.Name = "Root"
Root.Size = UDim2.new(0, 360, 0, 168) -- smaller
Root.Position = UDim2.new(0.5, 0, 0.46, 0)
Root.AnchorPoint = Vector2.new(0.5, 0.5)
Root.BackgroundColor3 = Color3.fromRGB(18, 38, 22)
Root.BackgroundTransparency = 1
Root.BorderSizePixel = 0
Root.ClipsDescendants = true
Root.Parent = ScreenGui

local RootCorner = Instance.new("UICorner")
RootCorner.CornerRadius = UDim.new(0, 12)
RootCorner.Parent = Root

local RootStroke = Instance.new("UIStroke")
RootStroke.Thickness = 1
RootStroke.Color = Color3.fromRGB(60, 200, 140)
RootStroke.Transparency = 0.12
RootStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
RootStroke.Parent = Root

local Glow = Instance.new("ImageLabel")
Glow.BackgroundTransparency = 1
Glow.AnchorPoint = Vector2.new(0.5, 0.5)
Glow.Position = UDim2.fromScale(0.5, 0.5)
Glow.Size = UDim2.new(1, 90, 1, 90)
Glow.Image = "rbxasset://textures/whiteSquare.png"
Glow.ImageColor3 = Color3.fromRGB(60, 210, 150)
Glow.ImageTransparency = 0.86
Glow.ScaleType = Enum.ScaleType.Slice
Glow.SliceCenter = Rect.new(10,10,246,246)
Glow.Parent = Root

local Bg = Instance.new("Frame")
Bg.Size = UDim2.fromScale(1, 1)
Bg.BackgroundColor3 = Root.BackgroundColor3
Bg.BackgroundTransparency = 1
Bg.BorderSizePixel = 0
Bg.Parent = Root

local BgCorner = Instance.new("UICorner")
BgCorner.CornerRadius = UDim.new(0, 12)
BgCorner.Parent = Bg

local BgGradient = Instance.new("UIGradient")
BgGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0.0, Color3.fromRGB(22, 56, 32)),
    ColorSequenceKeypoint.new(1.0, Color3.fromRGB(18, 96, 58))
})
BgGradient.Rotation = 90
BgGradient.Parent = Bg

local HeaderBar = Instance.new("Frame")
HeaderBar.BackgroundTransparency = 1
HeaderBar.Size = UDim2.new(1, -18, 0, 34)
HeaderBar.Position = UDim2.new(0, 9, 0, 8)
HeaderBar.Parent = Root

local Left = Instance.new("Frame")
Left.BackgroundTransparency = 1
Left.Size = UDim2.new(0.5, -4, 1, 0)
Left.Parent = HeaderBar

local Right = Instance.new("Frame")
Right.BackgroundTransparency = 1
Right.Size = UDim2.new(0.5, -4, 1, 0)
Right.Position = UDim2.new(0.5, 8, 0, 0)
Right.Parent = HeaderBar

local Title = Instance.new("TextLabel")
Title.BackgroundTransparency = 1
Title.AnchorPoint = Vector2.new(0, 1)
Title.Position = UDim2.new(0, 0, 1, 0)
Title.Size = UDim2.new(1, 0, 1, 0)
Title.Text = "OverHub Autofarm"
Title.Font = Enum.Font.GothamBold
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.TextTransparency = 1
Title.Parent = Left

local CopyBtn = Instance.new("TextButton")
CopyBtn.AnchorPoint = Vector2.new(1, 1)
CopyBtn.Position = UDim2.new(1, 0, 1, 0)
CopyBtn.Size = UDim2.new(0, 170, 1, 2)
CopyBtn.BackgroundTransparency = 1
CopyBtn.Text = "Copy Discord Link"
CopyBtn.Font = Enum.Font.GothamBold
CopyBtn.TextScaled = true
CopyBtn.TextColor3 = Color3.fromRGB(60, 200, 140)
CopyBtn.Parent = Right

local CopyCorner = Instance.new("UICorner")
CopyCorner.CornerRadius = UDim.new(0, 8)
CopyCorner.Parent = CopyBtn

local CopyStroke = Instance.new("UIStroke")
CopyStroke.Thickness = 1
CopyStroke.Color = Color3.fromRGB(60, 200, 140)
CopyStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
CopyStroke.Parent = CopyBtn

local Status = Instance.new("TextLabel")
Status.BackgroundTransparency = 1
Status.Size = UDim2.new(1, -30, 0, 64)
Status.Position = UDim2.new(0, 15, 0.46, -32)
Status.Text = "AUTOFARM: ON"
Status.Font = Enum.Font.GothamBlack
Status.TextScaled = true
Status.TextColor3 = Color3.fromRGB(95, 255, 185)
Status.TextTransparency = 1
Status.Parent = Root

local StatusGlow = Instance.new("Frame")
StatusGlow.BackgroundColor3 = Color3.fromRGB(95, 255, 185)
StatusGlow.BackgroundTransparency = 0.88
StatusGlow.Size = UDim2.new(0.92, 0, 0, 70)
StatusGlow.Position = UDim2.new(0.04, 0, 0.46, -35)
StatusGlow.BorderSizePixel = 0
StatusGlow.Parent = Root
local StatusGlowCorner = Instance.new("UICorner")
StatusGlowCorner.CornerRadius = UDim.new(0, 10)
StatusGlowCorner.Parent = StatusGlow
local StatusGlowGrad = Instance.new("UIGradient")
StatusGlowGrad.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0.0, Color3.fromRGB(95, 255, 185)),
    ColorSequenceKeypoint.new(1.0, Color3.fromRGB(60, 220, 150))
})
StatusGlowGrad.Transparency = NumberSequence.new{
    NumberSequenceKeypoint.new(0.0, 0.35),
    NumberSequenceKeypoint.new(0.6, 0.75),
    NumberSequenceKeypoint.new(1.0, 1.0)
}
StatusGlowGrad.Parent = StatusGlow

local DiamondCountLabel = Instance.new("TextLabel")
DiamondCountLabel.BackgroundTransparency = 1
DiamondCountLabel.Size = UDim2.new(1, -18, 0, 20)
DiamondCountLabel.Position = UDim2.new(0, 9, 1, -24)
DiamondCountLabel.Text = "Diamonds: 0"
DiamondCountLabel.Font = Enum.Font.GothamBold
DiamondCountLabel.TextScaled = true
DiamondCountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
DiamondCountLabel.TextXAlignment = Enum.TextXAlignment.Left
DiamondCountLabel.TextTransparency = 1
DiamondCountLabel.Parent = Root

-- fade-in
task.spawn(function()
    TweenService:Create(Blur, TweenInfo.new(0.30, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = 16}):Play()
    task.wait(0.18)
    TweenService:Create(Blur, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = 12}):Play()
    TweenService:Create(Root, TweenInfo.new(0.20, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0.06}):Play()
    TweenService:Create(Bg, TweenInfo.new(0.20, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
    TweenService:Create(Title, TweenInfo.new(0.16, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
    TweenService:Create(Status, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
    TweenService:Create(DiamondCountLabel, TweenInfo.new(0.16, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
    TweenService:Create(Glow, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {ImageTransparency = 0.86}):Play()
end)

-- copy
local DISCORD_LINK = "https://discord.gg/overhub"
local HiddenCopyBox = Instance.new("TextBox")
HiddenCopyBox.Size = UDim2.new(0, 1, 0, 1)
HiddenCopyBox.Position = UDim2.new(1, 9999, 1, 9999)
HiddenCopyBox.TextEditable = true
HiddenCopyBox.ClearTextOnFocus = false
HiddenCopyBox.Text = ""
HiddenCopyBox.Parent = ScreenGui

local function copyWithExecutor(text)
    local env = getfenv and getfenv() or _G
    local f = (env and env.setclipboard) or _G.setclipboard or _G.toclipboard
    if f and typeof(f) == "function" then
        return pcall(f, text)
    end
    return false
end
local function copyWithSetCore(text)
    local tries = 0
    while tries < 12 do
        tries += 1
        local ok = pcall(function() StarterGui:SetCore("SetClipboard", text) end)
        if ok then return true end
        task.wait(0.12)
    end
    return false
end
local function copyWithTextBox(text)
    HiddenCopyBox.Text = text
    HiddenCopyBox:CaptureFocus()
    HiddenCopyBox.CursorPosition = #HiddenCopyBox.Text + 1
    HiddenCopyBox.SelectionStart = 1
    return false
end
local function doCopy(text)
    if copyWithExecutor(text) then return true end
    if copyWithSetCore(text) then return true end
    return copyWithTextBox(text)
end
CopyBtn.MouseEnter:Connect(function()
    TweenService:Create(CopyBtn, TweenInfo.new(0.12), {TextColor3 = Color3.fromRGB(110, 255, 195)}):Play()
end)
CopyBtn.MouseLeave:Connect(function()
    TweenService:Create(CopyBtn, TweenInfo.new(0.12), {TextColor3 = Color3.fromRGB(60, 200, 140)}):Play()
end)
CopyBtn.MouseButton1Click:Connect(function()
    local ok = doCopy(DISCORD_LINK)
    local orig = CopyStroke.Color
    CopyStroke.Color = ok and Color3.fromRGB(120, 255, 200) or Color3.fromRGB(255, 180, 140)
    TweenService:Create(CopyBtn, TweenInfo.new(0.08, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, true), {Size = UDim2.new(0, 164, 1, 0)}):Play()
    task.delay(0.18, function() CopyStroke.Color = orig end)
end)

-- drag
local dragging, dragStart, startPos, dragInput = false, nil, nil, nil
local function updateDrag(input)
    local delta = input.Position - dragStart
    Root.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end
Root.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = Root.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)
Root.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        updateDrag(input)
    end
end)

_G.OverhubUI = {
    Root = Root,
    DiamondCountLabel = DiamondCountLabel,
    Status = Status,
    Blur = Blur,
}

-- END OF SNIPPET 1
-- COMMENT SPLIT HERE
--========================
-- V399 CORE + WEBHOOK + HOP RE-EXEC (QUEUE + DATA)
--========================
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local lp = Players.LocalPlayer
local PlaceID = game.PlaceId

local ui = _G.OverhubUI or {}
local Status = ui.Status
local DiamondCountLabel = ui.DiamondCountLabel

local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local TakeDiamonds = RemoteEvents:WaitForChild("RequestTakeDiamonds")
local ItemsFolder = Workspace:WaitForChild("Items")

-- CPS Nerf friend behavior in specific place
task.spawn(function()
    if game.PlaceId == 79546208627805 then
        local TeleportEvent = RemoteEvents:WaitForChild("TeleportEvent", 9e9)
        local function TeleportAdd(num)
            local args = {"Add", num}
            pcall(function()
                TeleportEvent:FireServer(unpack(args))
                task.wait(0.5)
                TeleportEvent:FireServer("Chosen", nil, 1)
            end)
        end
        while true do
            TeleportAdd(3); TeleportAdd(2); TeleportAdd(1)
            task.wait(0.3)
        end
    end
end)

-- External config
local G = getgenv and getgenv() or _G
local GLOBAL_WEBHOOK = rawget(_G, "Webhook") or rawget(G, "Webhook") or rawget(G, "WebhookURL") or ""
local MAX_SERVER_TIME = (rawget(G, "MaxServerTime") or 15)

local username = lp.Name
local displayName = lp.DisplayName

local function setStatus(t) if Status then Status.Text = t end end

-- Diamonds
local function getDiamondCount()
    local ok, v = pcall(function()
        local obj = Players[username].PlayerGui.Interface.DiamondCount.Count
        return tonumber(obj.Text) or 0
    end)
    return ok and v or 0
end
local function updateDiamondDisplay()
    local v = getDiamondCount()
    if DiamondCountLabel then DiamondCountLabel.Text = "Diamonds: " .. v end
    return v
end
task.spawn(function()
    local ok, obj = pcall(function() return Players[username].PlayerGui.Interface.DiamondCount.Count end)
    if ok and obj and obj:IsA("TextLabel") then
        obj:GetPropertyChangedSignal("Text"):Connect(updateDiamondDisplay)
        updateDiamondDisplay()
    else
        if DiamondCountLabel then DiamondCountLabel.Text = "Diamonds: N/A" end
    end
    while true do updateDiamondDisplay() task.wait(1) end
end)

-- HRP
local hrp
local function updateHRP()
    if lp.Character then hrp = lp.Character:WaitForChild("HumanoidRootPart") end
end
updateHRP()
lp.CharacterAdded:Connect(function() task.wait(0.5) updateHRP() end)

-- Webhook (POST JSON)
local function validUrl(u)
    return type(u)=="string" and #u>0 and string.find(u,"https://discord.com/api/webhooks/")
end
local function sendWebhook(summary)
    if not validUrl(GLOBAL_WEBHOOK) then return end
    local payload = { content = summary, username = "OverHub Autofarm", allowed_mentions = { parse = {} } }
    local json = HttpService:JSONEncode(payload)
    pcall(function()
        HttpService:PostAsync(GLOBAL_WEBHOOK, json, Enum.HttpContentType.ApplicationJson)
    end)
end
-- Use PostAsync with JSON body for Discord webhooks. [8]

-- Farm logic
local activeDiamonds, collectedDiamonds = {}, {}
local diamondsCollectedThisServer = 0

local function collectDiamond(d)
    if not d or activeDiamonds[d] or collectedDiamonds[d] then return end
    activeDiamonds[d] = true
    collectedDiamonds[d] = true
    diamondsCollectedThisServer += 1
    task.spawn(function()
        while d.Parent and hrp do
            pcall(TakeDiamonds.FireServer, TakeDiamonds, d)
            pcall(function() hrp.CFrame = d.CFrame + Vector3.new(0,3,0) end)
            task.wait(0.02)
        end
        activeDiamonds[d] = nil
    end)
end

local function scanDiamonds()
    for _, it in ipairs(ItemsFolder:GetChildren()) do
        if string.find(string.lower(it.Name), "diamond") then
            collectDiamond(it)
        end
    end
end

ItemsFolder.ChildAdded:Connect(function(ch)
    if string.find(string.lower(ch.Name), "diamond") then
        collectDiamond(ch)
    end
end)

local function fireChests()
    local list = {}
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if (obj:IsA("Model") or obj:IsA("Part")) and obj.Name:lower():find("chest") then
            for _, c in ipairs(obj:GetDescendants()) do
                if c:IsA("ProximityPrompt") then table.insert(list, c) end
            end
        end
    end
    for _, p in ipairs(list) do
        task.spawn(function()
            for i=1,5 do pcall(fireproximityprompt, p) task.wait(0.05) end
        end)
    end
    return #list
end

local function findStrongholdChestPrimary()
    local chest = Workspace:FindFirstChild("Stronghold Diamond Chest")
    if chest then
        local p = chest:FindFirstChild("PrimaryPart") or chest:FindFirstChildWhichIsA("BasePart")
        if p then return p end
    end
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") and obj.Name:lower():find("stronghold") and obj.Name:lower():find("chest") then
            local p = obj:FindFirstChild("PrimaryPart") or obj:FindFirstChildWhichIsA("BasePart")
            if p then return p end
        end
    end
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if (obj:IsA("Model") or obj:IsA("Part")) and obj.Name:lower():find("stronghold") then
            local p = obj:FindFirstChild("PrimaryPart") or obj:FindFirstChildWhichIsA("BasePart")
            if p then return p end
        end
    end
    return nil
end

local function snapToStrongholdAndFire()
    if not hrp then return false end
    local p = findStrongholdChestPrimary()
    if not p then return false end
    setStatus("Teleporting to chest...")
    pcall(function() hrp.CFrame = p.CFrame + Vector3.new(0,5,0) end)
    for _, child in ipairs(p.Parent:GetDescendants()) do
        if child:IsA("ProximityPrompt") then
            for i=1,8 do pcall(fireproximityprompt, child) task.wait(0.05) end
        end
    end
    return true
end

local function isDead()
    local chars = Workspace:FindFirstChild("Characters")
    if chars then
        for _, c in ipairs(chars:GetChildren()) do
            if c.Name:lower():find(lp.Name:lower()) or (displayName and c.Name:lower():find(displayName:lower())) then
                return true
            end
        end
    end
    if lp.Character then
        local hum = lp.Character:FindFirstChildOfClass("Humanoid")
        if hum and hum.Health <= 0 then return true end
    end
    return false
end

local function cleanChars()
    local chars = Workspace:FindFirstChild("Characters")
    if not chars then return end
    for _, c in ipairs(chars:GetChildren()) do
        local isMe = c.Name:lower():find(lp.Name:lower()) or (displayName and c.Name:lower():find(displayName:lower()))
        if not isMe then pcall(function() c:Destroy() end) end
    end
end

-- Auto re-exec helper
local function setupAutoExecMarker()
    if not ReplicatedStorage:FindFirstChild("DiamondFarmMarker") then
        local marker = Instance.new("StringValue")
        marker.Name = "DiamondFarmMarker"
        marker.Value = "DiamondFarmScript"
        marker.Parent = ReplicatedStorage
    end
end

-- Build queued code + TeleportData
local function buildArrivalCode()
    local g = getgenv and getgenv() or _G
    local webhook = rawget(_G,"Webhook") or rawget(g,"Webhook") or rawget(g,"WebhookURL") or ""
    local autoExec = rawget(_G,"AutoExecute")
    return ([[Webhook = %q
AutoExecute = %s
if AutoExecute and not _G.StopAuto then
    _G.StopAuto = false
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hellattexyss/testfarm/refs/heads/main/farmv399upd"))()
end]]):format(webhook, tostring(not not autoExec))
end

local function queueArrival()
    local code = buildArrivalCode()
    if typeof(queue_on_teleport) == "function" then
        pcall(queue_on_teleport, code)
    end
    -- TeleportData fallback (read by next client)
    local teleOpts = Instance.new("TeleportOptions")
    teleOpts:SetTeleportData({ OH_Auto = true, Code = code })
    return teleOpts
end
-- queue_on_teleport + TeleportOptions:SetTeleportData maximize re-exec reliability after Teleport. [23][4][9]

-- Hop (with queue + data)
local function hopServer()
    setStatus("Finding server...")
    if diamondsCollectedThisServer > 0 then
        sendWebhook(string.format("üíé Diamond Report\nüë§ %s (@%s)\nüí∞ Balance: %d\nüìà Collected: %d",
            displayName, username, getDiamondCount(), diamondsCollectedThisServer))
    end

    local ok, result = pcall(function()
        local url = "https://games.roblox.com/v1/games/"..PlaceID.."/servers/Public?sortOrder=Asc&limit=100"
        local body = game:HttpGet(url)
        return HttpService:JSONDecode(body)
    end)

    local teleOpts = queueArrival() -- must be created before TeleportX call

    if ok and result and result.data then
        local pool = {}
        for _, s in ipairs(result.data) do
            if s.playing < s.maxPlayers and s.id ~= game.JobId then
                table.insert(pool, s.id)
            end
        end
        if #pool > 0 then
            local target = pool[math.random(1, #pool)]
            TeleportService:TeleportToPlaceInstance(PlaceID, target, lp, nil, teleOpts)
            return true
        end
    end
    TeleportService:Teleport(PlaceID, lp, teleOpts) -- Teleport with options to carry data
    return true
end

local function hopWithAuto()
    diamondsCollectedThisServer = 0
    collectedDiamonds = {}
    local ok = pcall(hopServer)
    if not ok then
        local teleOpts = queueArrival()
        pcall(function() TeleportService:Teleport(PlaceID, lp, teleOpts) end)
    end
    return true
end

function startFarm()
    task.spawn(function()
        local startTick = tick()
        local hopCount, chestCheck = 0, 0
        setupAutoExecMarker()

        -- On arrival: try to re-run via TeleportData if executor blocked queue_on_teleport
        local data = TeleportService:GetLocalPlayerTeleportData()
        if typeof(data) == "table" and data.OH_Auto and type(data.Code)=="string" then
            local ok, err = pcall(function() loadstring(data.Code)() end)
            if ok then setStatus("Auto-exec via TeleportData") end
        end

        while true do
            cleanChars()

            if tick() - startTick > MAX_SERVER_TIME then
                setStatus("Auto-hopping (timeout)")
                hopWithAuto()
                startTick = tick()
                task.wait(2)
                continue
            end

            if isDead() then
                setStatus("Dead, hopping...")
                sendWebhook(string.format("‚ò†Ô∏è Death hop\nüë§ %s (@%s)\nüíé Balance: %d", displayName, username, getDiamondCount()))
                hopWithAuto()
                startTick = tick()
                task.wait(5)
            end

            if lp.Character and hrp then
                fireChests()
                scanDiamonds()

                chestCheck += 1
                if chestCheck >= 1 then
                    chestCheck = 0
                    if snapToStrongholdAndFire() then
                        setStatus("Found chest!")
                        task.wait(1)
                    end
                end

                hopCount += 1
                if hopCount >= 3 then
                    hopCount = 0
                    task.wait(1)
                    sendWebhook(string.format("üîÅ Periodic hop\nüë§ %s (@%s)\nüíé Collected: %d", displayName, username, diamondsCollectedThisServer))
                    hopWithAuto()
                    startTick = tick()
                    task.wait(3)
                else
                    task.wait(0.5)
                end
            else
                task.wait(0.5)
            end
        end
    end)
end

TeleportService.TeleportInitFailed:Connect(function(plr, result, err)
    setStatus("Teleport failed, retrying...")
    task.wait(0.75)
    hopWithAuto()
end)

startFarm()
