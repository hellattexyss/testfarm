-- Auto-execute across teleports (always TRUE, using provided URL)
queue_on_teleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/hellattexyss/testfarm/refs/heads/main/farmv399upd'))()")

-- Auto party/teleport add spam (lobby only, as-is)
if game.PlaceId == 79546208627805 then
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 9e9)
    local TeleportEvent = RemoteEvents:WaitForChild("TeleportEvent", 9e9)
    local function TeleportAdd(num)
        local args = { [1] = "Add", [2] = num }
        TeleportEvent:FireServer(unpack(args))
        task.wait(0.5)
        TeleportEvent:FireServer("Chosen", nil, 1)
    end
    task.spawn(function()
        while true do
            TeleportAdd(3); TeleportAdd(2); TeleportAdd(1)
            task.wait(0.3)
        end
    end)
end

-- Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

-- Player refs
local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- Blur intro
local camera = workspace.CurrentCamera
local Blur = Instance.new("BlurEffect")
Blur.Enabled = true
Blur.Size = 0
Blur.Parent = camera

-- Dedup old UIs
for _, n in ipairs({"DiamondFarmGUI","AutoFarmDiamondsGUI"}) do
    local f = PlayerGui:FindFirstChild(n)
    if f then f:Destroy() end
end

-- ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoFarmDiamondsGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = PlayerGui

-- Root panel (smaller, draggable)
local Root = Instance.new("Frame")
Root.Name = "Root"
Root.Size = UDim2.new(0, 360, 0, 200)
Root.Position = UDim2.new(0.5, 0, 0.48, 0)
Root.AnchorPoint = Vector2.new(0.5, 0.5)
Root.BackgroundColor3 = Color3.fromRGB(18, 38, 22)
Root.BackgroundTransparency = 1
Root.BorderSizePixel = 0
Root.ClipsDescendants = true
Root.Active = true
Root.Selectable = true
Root.Parent = ScreenGui

local RootCorner = Instance.new("UICorner")
RootCorner.CornerRadius = UDim.new(0, 14)
RootCorner.Parent = Root

local RootStroke = Instance.new("UIStroke")
RootStroke.Thickness = 1
RootStroke.Color = Color3.fromRGB(60, 200, 140)
RootStroke.Transparency = 0.1
RootStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
RootStroke.Parent = Root

-- Glow
local Glow = Instance.new("ImageLabel")
Glow.Name = "Glow"
Glow.BackgroundTransparency = 1
Glow.AnchorPoint = Vector2.new(0.5, 0.5)
Glow.Position = UDim2.fromScale(0.5, 0.5)
Glow.Size = UDim2.new(1, 80, 1, 80)
Glow.Image = "rbxasset://textures/whiteSquare.png"
Glow.ImageColor3 = Color3.fromRGB(60, 210, 150)
Glow.ImageTransparency = 0.86
Glow.ScaleType = Enum.ScaleType.Slice
Glow.SliceCenter = Rect.new(10,10,246,246)
Glow.Parent = Root

-- Background
local Bg = Instance.new("Frame")
Bg.Name = "Background"
Bg.Size = UDim2.fromScale(1, 1)
Bg.BackgroundColor3 = Root.BackgroundColor3
Bg.BackgroundTransparency = 1
Bg.BorderSizePixel = 0
Bg.Parent = Root

local BgCorner = Instance.new("UICorner")
BgCorner.CornerRadius = UDim.new(0, 14)
BgCorner.Parent = Bg

local BgGradient = Instance.new("UIGradient")
BgGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0.0, Color3.fromRGB(22, 56, 32)),
    ColorSequenceKeypoint.new(1.0, Color3.fromRGB(18, 96, 58))
})
BgGradient.Rotation = 90
BgGradient.Parent = Bg

-- Header
local HeaderBar = Instance.new("Frame")
HeaderBar.Name = "HeaderBar"
HeaderBar.BackgroundTransparency = 1
HeaderBar.Size = UDim2.new(1, -16, 0, 34)
HeaderBar.Position = UDim2.new(0, 8, 0, 8)
HeaderBar.Parent = Root

local Left = Instance.new("Frame")
Left.BackgroundTransparency = 1
Left.Size = UDim2.new(0.5, -4, 1, 0)
Left.Parent = HeaderBar

local Right = Instance.new("Frame")
Right.BackgroundTransparency = 1
Right.Size = UDim2.new(0.5, -4, 1, 0)
Right.Position = UDim2.new(0.5, 8, 0, 0)
Right.Parent = HeaderBar

-- Title
local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.BackgroundTransparency = 1
Title.AnchorPoint = Vector2.new(0, 1)
Title.Position = UDim2.new(0, 0, 1, 0)
Title.Size = UDim2.new(1, 0, 1, 0)
Title.Text = "OverHub Autofarm"
Title.Font = Enum.Font.GothamBold
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.TextTransparency = 1
Title.Parent = Left

-- Right buttons container
local RightButtons = Instance.new("Frame")
RightButtons.BackgroundTransparency = 1
RightButtons.Size = UDim2.new(1, 0, 1, 0)
RightButtons.Parent = Right

-- Copy Discord button
local CopyBtn = Instance.new("TextButton")
CopyBtn.Name = "CopyDiscord"
CopyBtn.AnchorPoint = Vector2.new(1, 1)
CopyBtn.Position = UDim2.new(1, 0, 1, 0)
CopyBtn.Size = UDim2.new(0, 150, 1, 2)
CopyBtn.BackgroundTransparency = 1
CopyBtn.Text = "Copy Discord Link"
CopyBtn.Font = Enum.Font.GothamBold
CopyBtn.TextScaled = true
CopyBtn.TextColor3 = Color3.fromRGB(60, 200, 140)
CopyBtn.Parent = RightButtons

local CopyCorner = Instance.new("UICorner")
CopyCorner.CornerRadius = UDim.new(0, 10)
CopyCorner.Parent = CopyBtn

local CopyStroke = Instance.new("UIStroke")
CopyStroke.Thickness = 1
CopyStroke.Color = Color3.fromRGB(60, 200, 140)
CopyStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
CopyStroke.Parent = CopyBtn

-- Info button (bottom-right)
local InfoBtn = Instance.new("TextButton")
InfoBtn.Name = "InfoBtn"
InfoBtn.AnchorPoint = Vector2.new(1, 1)
InfoBtn.Position = UDim2.new(1, -10, 1, -10)
InfoBtn.Size = UDim2.new(0, 118, 0, 28)
InfoBtn.BackgroundTransparency = 1
InfoBtn.Text = "Info"
InfoBtn.Font = Enum.Font.GothamBold
InfoBtn.TextScaled = true
InfoBtn.TextColor3 = Color3.fromRGB(60, 200, 140)
InfoBtn.Parent = Root

local InfoCorner = Instance.new("UICorner")
InfoCorner.CornerRadius = UDim.new(0, 10)
InfoCorner.Parent = InfoBtn

local InfoStroke = Instance.new("UIStroke")
InfoStroke.Thickness = 1
InfoStroke.Color = Color3.fromRGB(60, 200, 140)
InfoStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
InfoStroke.Parent = InfoBtn

-- Status
local Status = Instance.new("TextLabel")
Status.Name = "Status"
Status.BackgroundTransparency = 1
Status.Size = UDim2.new(1, -28, 0, 70)
Status.Position = UDim2.new(0, 14, 0.46, -35)
Status.Text = "AUTOFARM: ON"
Status.Font = Enum.Font.GothamBlack
Status.TextScaled = true
Status.TextColor3 = Color3.fromRGB(95, 255, 185)
Status.TextTransparency = 1
Status.Parent = Root

local StatusGlow = Instance.new("Frame")
StatusGlow.Name = "StatusGlow"
StatusGlow.BackgroundColor3 = Color3.fromRGB(95, 255, 185)
StatusGlow.BackgroundTransparency = 0.88
StatusGlow.Size = UDim2.new(0.92, 0, 0, 74)
StatusGlow.Position = UDim2.new(0.04, 0, 0.46, -37)
StatusGlow.BorderSizePixel = 0
StatusGlow.Parent = Root

local StatusGlowCorner = Instance.new("UICorner")
StatusGlowCorner.CornerRadius = UDim.new(0, 12)
StatusGlowCorner.Parent = StatusGlow

local StatusGlowGrad = Instance.new("UIGradient")
StatusGlowGrad.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0.0, Color3.fromRGB(95, 255, 185)),
    ColorSequenceKeypoint.new(1.0, Color3.fromRGB(60, 220, 150))
})
StatusGlowGrad.Transparency = NumberSequence.new{
    NumberSequenceKeypoint.new(0.0, 0.35),
    NumberSequenceKeypoint.new(0.5, 0.75),
    NumberSequenceKeypoint.new(1.0, 1.0)
}
StatusGlowGrad.Parent = StatusGlow

-- Diamond counter label
local DiamondCountLabel = Instance.new("TextLabel")
DiamondCountLabel.Name = "DiamondCountLabel"
DiamondCountLabel.BackgroundTransparency = 1
DiamondCountLabel.Size = UDim2.new(1, -20, 0, 20)
DiamondCountLabel.Position = UDim2.new(0, 10, 1, -24)
DiamondCountLabel.Text = "Diamonds: 0"
DiamondCountLabel.Font = Enum.Font.GothamBold
DiamondCountLabel.TextScaled = true
DiamondCountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
DiamondCountLabel.TextXAlignment = Enum.TextXAlignment.Left
DiamondCountLabel.TextTransparency = 1
DiamondCountLabel.Parent = Root

-- Info Tab
local InfoTab = Instance.new("Frame")
InfoTab.Name = "InfoTab"
InfoTab.Visible = false
InfoTab.Size = UDim2.fromScale(1, 1)
InfoTab.BackgroundTransparency = 1
InfoTab.Parent = Root

local InfoBackdrop = Instance.new("Frame")
InfoBackdrop.Name = "InfoBackdrop"
InfoBackdrop.Size = UDim2.new(1, 0, 1, 0)
InfoBackdrop.BackgroundColor3 = Color3.fromRGB(18, 38, 22)
InfoBackdrop.BackgroundTransparency = 0.06
InfoBackdrop.Parent = InfoTab

local InfoBackdropCorner = Instance.new("UICorner")
InfoBackdropCorner.CornerRadius = UDim.new(0, 14)
InfoBackdropCorner.Parent = InfoBackdrop

local InfoBackdropStroke = Instance.new("UIStroke")
InfoBackdropStroke.Thickness = 1
InfoBackdropStroke.Color = Color3.fromRGB(60, 200, 140)
InfoBackdropStroke.Transparency = 0.1
InfoBackdropStroke.Parent = InfoBackdrop

local InfoHeader = Instance.new("TextLabel")
InfoHeader.Name = "InfoHeader"
InfoHeader.BackgroundTransparency = 1
InfoHeader.Size = UDim2.new(1, -16, 0, 30)
InfoHeader.Position = UDim2.new(0, 8, 0, 8)
InfoHeader.Text = "Changelogs"
InfoHeader.Font = Enum.Font.GothamBlack
InfoHeader.TextScaled = true
InfoHeader.TextColor3 = Color3.fromRGB(255, 255, 255)
InfoHeader.Parent = InfoBackdrop

local CloseInfo = Instance.new("TextButton")
CloseInfo.Name = "CloseInfo"
CloseInfo.AnchorPoint = Vector2.new(1, 0)
CloseInfo.Position = UDim2.new(1, -8, 0, 8)
CloseInfo.Size = UDim2.new(0, 28, 0, 28)
CloseInfo.BackgroundTransparency = 1
CloseInfo.Text = "✕"
CloseInfo.Font = Enum.Font.GothamBold
CloseInfo.TextScaled = true
CloseInfo.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseInfo.Parent = InfoBackdrop

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 8)
CloseCorner.Parent = CloseInfo

local CloseStroke = Instance.new("UIStroke")
CloseStroke.Thickness = 1
CloseStroke.Color = Color3.fromRGB(60, 200, 140)
CloseStroke.Parent = CloseInfo

local InfoBody = Instance.new("ScrollingFrame")
InfoBody.Name = "InfoBody"
InfoBody.Active = true
InfoBody.BorderSizePixel = 0
InfoBody.BackgroundTransparency = 1
InfoBody.Size = UDim2.new(1, -16, 1, -50)
InfoBody.Position = UDim2.new(0, 8, 0, 42)
InfoBody.CanvasSize = UDim2.new(0, 0, 0, 0)
InfoBody.ScrollBarThickness = 4
InfoBody.Parent = InfoBackdrop

local function addLogLine(parent, text)
    local lbl = Instance.new("TextLabel")
    lbl.BackgroundTransparency = 1
    lbl.Size = UDim2.new(1, -4, 0, 18)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Text = text
    lbl.Font = Enum.Font.Gotham
    lbl.TextScaled = true
    lbl.TextColor3 = Color3.fromRGB(220, 255, 240)
    lbl.Parent = parent
end

local function populateChangelogs()
    InfoBody:ClearAllChildren()
    local list = Instance.new("UIListLayout")
    list.Padding = UDim.new(0, 6)
    list.SortOrder = Enum.SortOrder.LayoutOrder
    list.Parent = InfoBody
    addLogLine(InfoBody, "[+] Farm logic merged and fixed.")
    addLogLine(InfoBody, "[+] Server hop + chest scan + auto-exec.")
    addLogLine(InfoBody, "[+] Lag clear on non-lobby join/hop.")
    addLogLine(InfoBody, "[+] Diamond counter + notifications.")
    addLogLine(InfoBody, "[-] Webhook excluded.")
    addLogLine(InfoBody, "[+] https://discord.gg/overhub — Join for early access!")
    task.wait()
    InfoBody.CanvasSize = UDim2.new(0, 0, 0, list.AbsoluteContentSize.Y + 8)
end

-- Intro tweens
local function tween(o, ti, props) TweenService:Create(o, ti, props):Play() end
task.spawn(function()
    tween(Blur, TweenInfo.new(0.30, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = 16})
    task.wait(0.18)
    tween(Blur, TweenInfo.new(0.20, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = 12})
    tween(Root, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0.06})
    tween(Bg, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0})
    tween(Title, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0})
    tween(Status, TweenInfo.new(0.24, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0})
    tween(DiamondCountLabel, TweenInfo.new(0.16, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0})
    tween(Glow, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {ImageTransparency = 0.86})
end)

-- Clipboard
local DISCORD_LINK = "https://discord.gg/overhub"
local HiddenCopyBox = Instance.new("TextBox")
HiddenCopyBox.Name = "HiddenCopyBox"
HiddenCopyBox.Size = UDim2.new(0, 1, 0, 1)
HiddenCopyBox.Position = UDim2.new(1, 9999, 1, 9999)
HiddenCopyBox.TextEditable = true
HiddenCopyBox.ClearTextOnFocus = false
HiddenCopyBox.Text = ""
HiddenCopyBox.Parent = ScreenGui

local function copyWithExecutor(t)
    local env = getfenv and getfenv() or _G
    local f = (env and env.setclipboard) or _G.setclipboard or _G.toclipboard
    if f and typeof(f) == "function" then return pcall(f, t) end
    return false
end
local function copyWithSetCore(t)
    for i=1,14 do
        local ok = pcall(function() StarterGui:SetCore("SetClipboard", t) end)
        if ok then return true end
        task.wait(0.12)
    end
    return false
end
local function copyWithTextBox(t)
    HiddenCopyBox.Text = t
    HiddenCopyBox:CaptureFocus()
    HiddenCopyBox.CursorPosition = #HiddenCopyBox.Text + 1
    HiddenCopyBox.SelectionStart = 1
    return false
end
local function doCopy(t)
    if copyWithExecutor(t) then return true end
    if copyWithSetCore(t) then return true end
    copyWithTextBox(t)
    return false
end

CopyBtn.MouseEnter:Connect(function()
    tween(CopyBtn, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(110, 255, 195)})
end)
CopyBtn.MouseLeave:Connect(function()
    tween(CopyBtn, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(60, 200, 140)})
end)
CopyBtn.MouseButton1Click:Connect(function()
    local ok = doCopy(DISCORD_LINK)
    local orig = CopyStroke.Color
    CopyStroke.Color = ok and Color3.fromRGB(120, 255, 200) or Color3.fromRGB(255, 180, 140)
    TweenService:Create(CopyBtn, TweenInfo.new(0.08, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, true),
        {Size = UDim2.new(0, 146, 1, 0)}):Play()
    task.delay(0.18, function() CopyStroke.Color = orig end)
end)

-- Info toggling
local function showInfo()
    pcall(populateChangelogs)
    for _, child in ipairs(Root:GetChildren()) do
        if child ~= InfoTab and child:IsA("GuiObject") then child.Visible = false end
    end
    InfoTab.Visible = true
end
local function hideInfo()
    InfoTab.Visible = false
    for _, child in ipairs(Root:GetChildren()) do
        if child ~= InfoTab and child:IsA("GuiObject") then child.Visible = true end
    end
end
InfoBtn.MouseButton1Click:Connect(showInfo)
CloseInfo.MouseButton1Click:Connect(hideInfo)

-- Dragging (mouse + touch)
do
    local dragging, dragStart, startPos
    local function updateDrag(input)
        local delta = input.Position - dragStart
        Root.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    Root.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = Root.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    Root.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            if dragging then updateDrag(input) end
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateDrag(input)
        end
    end)
end

-- Export for farm snippet
_G.OverhubUI = {
    Root = Root,
    DiamondCountLabel = DiamondCountLabel,
    StarterGui = StarterGui,
    Lighting = Lighting,
    RunService = RunService,
    Debris = Debris,
}
-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")

local Player = Players.LocalPlayer
local PlaceID = game.PlaceId

local ui = _G.OverhubUI or {}
local DiamondCountLabel = ui.DiamondCountLabel
local StarterGui = ui.StarterGui
local RunService = ui.RunService
local Debris = ui.Debris

-- Remotes/containers
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local TakeDiamonds = RemoteEvents:WaitForChild("RequestTakeDiamonds")
local ItemsFolder = Workspace:WaitForChild("Items")

-- Safe proximity trigger
local function firePromptSafe(prompt)
    if typeof(fireproximityprompt) == "function" then
        return pcall(fireproximityprompt, prompt)
    end
    local ok = pcall(function()
        prompt.HoldDuration = 0
        prompt.Enabled = true
        prompt:InputHoldBegin()
        task.wait(0.05)
        prompt:InputHoldEnd()
    end)
    return ok
end

-- Config
getgenv().MaxServerTime = getgenv().MaxServerTime or 15

-- Lag clear
local function ClearLag()
    pcall(function()
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 9e9
        Lighting.Brightness = 1
        for _, eff in ipairs(Lighting:GetChildren()) do
            if eff:IsA("BloomEffect") or eff:IsA("DepthOfFieldEffect") or eff:IsA("SunRaysEffect") or eff:IsA("ColorCorrectionEffect") then
                eff.Enabled = false
            end
        end
    end)
    pcall(function()
        local cam = workspace.CurrentCamera
        for _, eff in ipairs(cam:GetChildren()) do
            if eff:IsA("BlurEffect") or eff:IsA("SunRaysEffect") or eff:IsA("ColorCorrectionEffect") then eff.Enabled = false end
        end
    end)
    pcall(function() settings().Rendering.QualityLevel = Enum.QualityLevel.Level01 end)
    pcall(function() settings().Physics.AllowSleep = true end)
    pcall(function() Debris.MaxItems = 50 end)
    local killClasses = {"ParticleEmitter","Trail","Fire","Smoke","Sparkles","PointLight","SpotLight","SurfaceLight","Highlight","Beam"}
    local function bad(n) n = string.lower(n or ""); return n:find("decal") or n:find("particle") or n:find("vfx") or n:find("smoke") or n:find("sparks") end
    for _, d in ipairs(Workspace:GetDescendants()) do
        for _, c in ipairs(killClasses) do if d:IsA(c) then pcall(function() d.Enabled = false end) end end
        if d:IsA("Decal") or d:IsA("Texture") then pcall(function() d.Transparency = 1 end) end
        if d:IsA("Sound") then pcall(function() d.Playing = false d.Volume = 0 end) end
        if d:IsA("BasePart") then pcall(function() d.CastShadow = false d.Reflectance = 0 d.Material = Enum.Material.Plastic end) end
        if bad(d.Name) then pcall(function() if d:IsA("ParticleEmitter") or d:IsA("Beam") then d.Enabled = false end end) end
    end
end
task.spawn(function() if PlaceID ~= 79546208627805 then ClearLag() end end)

-- Diamond counter + notification
local username = Player.Name
local displayName = Player.DisplayName

local function getDiamondCount()
    local ok, result = pcall(function()
        local obj = Players[username].PlayerGui.Interface.DiamondCount.Count
        return tonumber(obj.Text) or 0
    end)
    return ok and result or 0
end

local lastCount = getDiamondCount()
local function notifyCollected(newCount, oldCount)
    if newCount and oldCount and newCount > oldCount then
        pcall(function()
            StarterGui:SetCore("SendNotification", {
                Title = "Collected 1 Diamond",
                Text = "Balance: " .. tostring(newCount),
                Duration = 2
            })
        end)
    end
end

local function updateDiamondDisplay()
    local n = getDiamondCount()
    lastCount = n
    if DiamondCountLabel then DiamondCountLabel.Text = "Diamonds: " .. n end
    return n
end

local function bindDiamondListener()
    local ok, obj = pcall(function()
        return Players[username].PlayerGui.Interface.DiamondCount.Count
    end)
    if ok and obj and obj:IsA("TextLabel") then
        obj:GetPropertyChangedSignal("Text"):Connect(function()
            local before = lastCount
            local now = tonumber(obj.Text) or before
            lastCount = now
            if DiamondCountLabel then DiamondCountLabel.Text = "Diamonds: " .. now end
            notifyCollected(now, before)
        end)
        updateDiamondDisplay()
    else
        if DiamondCountLabel then DiamondCountLabel.Text = "Diamonds: N/A" end
        task.spawn(function()
            while true do
                local before = lastCount
                local now = getDiamondCount()
                if now ~= before then
                    lastCount = now
                    if DiamondCountLabel then DiamondCountLabel.Text = "Diamonds: " .. now end
                    notifyCollected(now, before)
                end
                task.wait(1)
            end
        end)
    end
end
task.spawn(bindDiamondListener)

-- HRP tracking
local HRP
local function updateHRP()
    if Player.Character then
        HRP = Player.Character:WaitForChild("HumanoidRootPart")
    end
end
updateHRP()
Player.CharacterAdded:Connect(function()
    updateHRP()
    task.delay(1, function()
        lastCount = getDiamondCount()
        if PlaceID ~= 79546208627805 then ClearLag() end
    end)
end)

-- Collector
local activeDiamonds, seenDiamonds = {}, {}
local function collectDiamond(d)
    if not d or not d.Parent then return end
    if activeDiamonds[d] or seenDiamonds[d] then return end
    activeDiamonds[d] = true
    seenDiamonds[d] = true
    task.spawn(function()
        local tries = 0
        local before = getDiamondCount()
        while d.Parent and HRP and tries < 150 do
            tries += 1
            pcall(function() TakeDiamonds:FireServer(d) end)
            pcall(function() HRP.CFrame = d.CFrame + Vector3.new(0,3,0) end)
            task.wait(0.03)
            if getDiamondCount() > before then break end
        end
        activeDiamonds[d] = nil
    end)
end

local function scanDiamonds()
    for _, d in ipairs(ItemsFolder:GetChildren()) do
        if tostring(d.Name):lower():find("diamond") then collectDiamond(d) end
    end
end
ItemsFolder.ChildAdded:Connect(function(c)
    if tostring(c.Name):lower():find("diamond") then collectDiamond(c) end
end)

-- Chest helpers (improved: force-trigger, then wait for diamonds)
local function fireNearbyPrompts(model, attempts)
    attempts = attempts or 10
    local prompts = {}
    for _, child in ipairs(model:GetDescendants()) do
        if child:IsA("ProximityPrompt") then table.insert(prompts, child) end
    end
    for _ = 1, attempts do
        for _, prompt in ipairs(prompts) do
            task.spawn(function() firePromptSafe(prompt) end)
        end
        task.wait(0.08)
    end
end

local function findStrongholdChest()
    local chest = Workspace:FindFirstChild("Stronghold Diamond Chest")
    if chest then
        local p = chest:FindFirstChild("PrimaryPart") or chest:FindFirstChildWhichIsA("BasePart")
        if p then return p end
    end
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") and obj.Name:lower():find("stronghold") and obj.Name:lower():find("chest") then
            local p = obj:FindFirstChild("PrimaryPart") or obj:FindFirstChildWhichIsA("BasePart")
            if p then return p end
        end
    end
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if (obj:IsA("Model") or obj:IsA("Part")) and obj.Name:lower():find("stronghold") then
            local p = obj:FindFirstChild("PrimaryPart") or obj:FindFirstChildWhichIsA("BasePart")
            if p then return p end
        end
    end
    return nil
end

local function teleportToChestAndCollect()
    if not HRP then return false end
    local chestPart = findStrongholdChest()
    if not chestPart then return false end

    if DiamondCountLabel then DiamondCountLabel.Text = "Teleporting to chest..." end
    pcall(function() HRP.CFrame = chestPart.CFrame + Vector3.new(0, 5, 0) end)

    local chestModel = chestPart.Parent
    fireNearbyPrompts(chestModel, 14)

    -- Wait for diamond drops and collect before hopping
    local before = getDiamondCount()
    local t0 = tick()
    local collected = false

    -- Scan for up to 4 seconds for new diamonds near the chest, then 1.5s reserve for collecting
    while tick() - t0 < 5.5 do
        pcall(scanDiamonds)
        task.wait(0.08)
        local now = getDiamondCount()
        if now > before then
            collected = true
            before = now
            -- keep sweeping shortly to grab remaining
            local sweepEnd = tick() + 1.25
            while tick() < sweepEnd do
                pcall(scanDiamonds)
                task.wait(0.06)
            end
            break
        end
    end

    return collected
end

-- ===================== Strict not-full server hopping =====================

local HopCache = {
    nextCursor = nil,
    visited = {},
    visitedQueue = {},
    maxVisited = 250,
    lastCursorReset = 0,
}

local function markVisited(id)
    if HopCache.visited[id] then return end
    HopCache.visited[id] = true
    table.insert(HopCache.visitedQueue, id)
    if #HopCache.visitedQueue > HopCache.maxVisited then
        local old = table.remove(HopCache.visitedQueue, 1)
        HopCache.visited[old] = nil
    end
end

local function fetchServerPage(cursor)
    local base = "https://games.roblox.com/v1/games/"
    local url = base .. PlaceID .. "/servers/Public?sortOrder=Asc&limit=100" .. (cursor and ("&cursor=" .. HttpService:UrlEncode(cursor)) or "")
    local response = game:HttpGet(url)
    return HttpService:JSONDecode(response)
end

-- Strict filter: never choose full servers; keep headroom to avoid race joins
local HEADROOM = 1 -- require at least 1 free slot
local function collectCandidates(page)
    local out = {}
    if not page or not page.data then return out end
    for _, s in ipairs(page.data) do
        local playing = tonumber(s.playing) or 0
        local maxp = tonumber(s.maxPlayers) or 0
        local id = s.id
        local free = maxp - playing
        if id and id ~= game.JobId and maxp > 0 and free >= HEADROOM and not HopCache.visited[id] then
            local occupancy = playing / maxp
            local score = occupancy * 100 + playing
            table.insert(out, {id = id, free = free, playing = playing, maxp = maxp, score = score})
        end
    end
    table.sort(out, function(a, b)
        if a.free ~= b.free then return a.free > b.free end
        return a.score < b.score
    end)
    return out
end

local function chooseBest(cands)
    if #cands == 0 then return nil end
    -- Pick among best 5 with most free slots to avoid stampeding
    local k = math.min(5, #cands)
    return cands[math.random(1, k)].id
end

local function fastFindServer()
    local ok, res = pcall(function() return fetchServerPage(HopCache.nextCursor) end)
    if not ok or not res then return nil end
    local cands = collectCandidates(res)
    -- advance cursor for next call
    HopCache.nextCursor = res.nextPageCursor
    if not HopCache.nextCursor then
        -- loop back after finishing pages
        HopCache.nextCursor = nil
    end
    return chooseBest(cands)
end

local function hopServer()
    if DiamondCountLabel then DiamondCountLabel.Text = "Finding non-full server..." end
    for i = 1, 4 do
        local id = fastFindServer()
        if id then
            markVisited(id)
            TeleportService:TeleportToPlaceInstance(PlaceID, id, Player)
            return true
        end
        task.wait(0.12)
    end
    TeleportService:Teleport(PlaceID, Player)
    return true
end

-- =======================================================================

-- Death detection + Characters cleanup
local function isDead()
    local chars = Workspace:FindFirstChild("Characters")
    if chars then
        for _, child in ipairs(chars:GetChildren()) do
            if string.find(child.Name:lower(), Player.Name:lower()) or
               (displayName and string.find(child.Name:lower(), displayName:lower())) then
                return true
            end
        end
    end
    if Player.Character then
        local hum = Player.Character:FindFirstChildOfClass("Humanoid")
        if hum and hum.Health <= 0 then return true end
    end
    return false
end

local function cleanChars()
    local chars = Workspace:FindFirstChild("Characters")
    if chars then
        for _, child in ipairs(chars:GetChildren()) do
            local keep = false
            if string.find(child.Name:lower(), Player.Name:lower()) then keep = true end
            if displayName and string.find(child.Name:lower(), displayName:lower()) then keep = true end
            if not keep then pcall(function() child:Destroy() end) end
        end
    end
end
cleanChars()

-- Auto-exec markers
local function setupAutoExec()
    if not ReplicatedStorage:FindFirstChild("DiamondFarmMarker") then
        local marker = Instance.new("StringValue")
        marker.Name = "DiamondFarmMarker"
        marker.Value = "DiamondFarmScript"
        marker.Parent = ReplicatedStorage
    end
    if ReplicatedStorage:FindFirstChild("DiamondFarmTeleported") then
        ReplicatedStorage:FindFirstChild("DiamondFarmTeleported"):Destroy()
        task.delay(1.2, function() if PlaceID ~= 79546208627805 then ClearLag() end end)
        task.wait(0.8)
        startFarm()
        return
    end
end

local function prepTeleport()
    local teleportMarker = Instance.new("BoolValue")
    teleportMarker.Name = "DiamondFarmTeleported"
    teleportMarker.Value = true
    teleportMarker.Parent = ReplicatedStorage
end

local function hopWithAuto()
    prepTeleport()
    activeDiamonds, seenDiamonds = {}, {}
    local ok = pcall(hopServer)
    if not ok then pcall(function() TeleportService:Teleport(PlaceID, Player) end) end
    return true
end

-- Main loop
function startFarm()
    task.spawn(function()
        local hopCount, chestCheck = 0, 0
        local serverStartTime = tick()
        while true do
            cleanChars()

            if tick() - serverStartTime > (getgenv().MaxServerTime or 15) then
                if DiamondCountLabel then DiamondCountLabel.Text = "Auto-hopping (timeout)" end
                hopWithAuto()
                serverStartTime = tick()
                task.wait(2)
            end

            if isDead() then
                if DiamondCountLabel then DiamondCountLabel.Text = "Dead, hopping..." end
                hopWithAuto()
                serverStartTime = tick()
                task.wait(5)
            end

            if Player.Character and HRP then
                pcall(scanDiamonds)

                chestCheck += 1
                if chestCheck >= 1 then
                    chestCheck = 0
                    local collected = teleportToChestAndCollect()
                    if collected then
                        if DiamondCountLabel then DiamondCountLabel.Text = "Chest collected!" end
                        task.wait(0.6)
                    else
                        if DiamondCountLabel then DiamondCountLabel.Text = "Chest not ready" end
                    end
                end

                -- Faster hop cadence (unchanged from previous fast version)
                hopCount += 1
                if hopCount >= 2 then
                    hopCount = 0
                    task.wait(0.15)
                    hopWithAuto()
                    serverStartTime = tick()
                    task.wait(0.25)
                else
                    task.wait(0.25)
                end
            else
                task.wait(0.5)
            end
        end
    end)
end

-- Faster failure retry
pcall(function()
    if _G.__Overhub_TIF_Conn then _G.__Overhub_TIF_Conn:Disconnect() end
end)
_G.__Overhub_TIF_Conn = TeleportService.TeleportInitFailed:Connect(function(_, result)
    if DiamondCountLabel then DiamondCountLabel.Text = "Teleport failed, retrying..." end
    task.wait(0.25)
    hopWithAuto()
end)

pcall(function()
    if _G.__Overhub_TF_Conn then _G.__Overhub_TF_Conn:Disconnect() end
    _G.__Overhub_TF_Conn = TeleportService.TeleportFailed:Connect(function(_, err)
        if DiamondCountLabel then DiamondCountLabel.Text = "Teleport failed, retrying..." end
        task.wait(0.25)
        hopWithAuto()
    end)
end)

-- Reduce max per-server time slightly for faster rotation, still overrideable
getgenv().MaxServerTime = math.min(getgenv().MaxServerTime or 15, 10)

setupAutoExec()
startFarm()
